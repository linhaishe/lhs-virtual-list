
# 论文修改稿件

## 1系统开发

本后台管理系统的开发环境是：使用的32位macOS Ventura的操作系统，服务器使用Heroku，数据库采用MySQL5.6.24，开发语言Node v16.20.0，React16。

### 4.1.1前端代码组织

前端项目使用飞冰 (ICE)管理工程项目，引入依赖文件，配置开发环境，组织代码打包上线。前端项目文件组织大致划分了buildTools、mock、public、src等四个文件夹，src文件下会有component、pages、utils等文件夹。buildTools包含的是构建导出后的会使用的基础工具。mock包含的是本地的一些测试文件数据，public用于存放静态资源的目录，此目录下所有的文件会被复制到构建产物目录中。src是用于存放源码的目录。

// 截图

### 4.1.2后端代码组织

后端项目使用node和express-session搭建项目，后端项目文件组织结构分别为config、controller、router等三个文件夹，config包含整个项目连接数据库的代码，controller包含整个项目中各个页面的接口处理，是业务逻辑层实现代码的地方。router包含所有需要用到的接口的定义。

// 截图

### 4.1.3前端请求后端数据方式

这段代码需要实现一个正常的 HTTP 请求配置，包括跨域携带 cookie 和 token，设置超时时间，并设置请求和响应的拦截器。在请求成功时，如果业务状态码为 200，则自动解析 result 数据，无需逐层判断获取数据。如果业务状态码不是 200，则全局提示服务端的错误信息。如果 HTTP 请求不成功，则全局提示报错信息。另外，当 HTTP 请求或业务状态码为 401 时，需要执行注销操作。 还有一个全局的 loading 配置，默认开启，但可配置关闭。此外，由于后端问题，我们在前端加入防抖节流。

```js
import axios, { AxiosInstance, AxiosRequestConfig } from "axios";
import { Message } from "@alifd/next";
import { jumpLogin } from "@/utils";
import { Loading } from "@alifd/next";

let loadingInstance = null;
let requestNum = 0;

const addLoading = () => {
  // 增加loading 如果pending请求数量等于1，弹出loading, 防止重复弹出
  requestNum++;
  if (requestNum == 1) {
    loadingInstance = Loading.service({
      text: "正在努力加载中....",
      background: "rgba(0, 0, 0, 0)",
    });
  }
};

const cancelLoading = () => {
  // 取消loading 如果pending请求数量等于0，关闭loading
  requestNum--;
  if (requestNum === 0) loadingInstance?.close();
};

export const createAxiosByinterceptors = (
  config?: AxiosRequestConfig
): AxiosInstance => {
  const instance = axios.create({
    timeout: 1000,    //超时配置
    withCredentials: true,  //跨域携带cookie
    ...config,   // 自定义配置覆盖基本配置
  });

  // 添加请求拦截器
  instance.interceptors.request.use(
    function (config: any) {
      // 在发送请求之前做些什么
      const { loading = true } = config;
      console.log("config:", config);
      // config.headers.Authorization = vm.$Cookies.get("vue_admin_token");
      if (loading) addLoading();
      return config;
    },
    function (error) {
      // 对请求错误做些什么
      return Promise.reject(error);
    }
  );

  // 添加响应拦截器
  instance.interceptors.response.use(
    function (response) {
      // 对响应数据做点什么
      console.log("response:", response);
      const { loading = true } = response.config;
      if (loading) cancelLoading();
      const { code, data, message } = response.data;
      if (code === 200) return data;
      else if (code === 401) {
        jumpLogin();
      } else {
         Message.error(message);
         return Promise.reject(response.data);
      }
    },
    function (error) {
      // 对响应错误做点什么
      console.log("error-response:", error.response);
      console.log("error-config:", error.config);
      console.log("error-request:", error.request);
      const { loading = true } = error.config;
      if (loading) cancelLoading();
      if (error.response) {
        if (error.response.status === 401) {
          jumpLogin();
        }
      }
      Message.error(error?.response?.data?.message || "服务端异常");
      return Promise.reject(error);
    }
  );
  return instance;
};
```

## 4.2页面布局设计与实现

​		函数 layoutContainer：这个函数以 layoutConfig 对象作为参数，其中包含布局的配置选项。它解构了 layoutConfig 对象以提取诸如 showSideBar、simpleHeader 和 isEmpty 等属性。如果 layoutConfig 为 null 或 undefined，则默认这些属性为 false。接着，它使用 getPageLayoutConfig() 函数获取当前页面的布局配置。这可能会获取特定于正在渲染的页面的一些设置。进一步解构 pageConfig 对象以提取诸如 useLoginInfo、showFoot、showAvatar 和 isRedirect 等属性。这些属性可能控制用户认证、页脚可见性和重定向等功能。如果 isRedirect 为 true，则返回一个函数，直接渲染其子元素，有效地跳过布局。renderContent 函数检查当前页面是否有权限查看。如果有权限，则渲染子元素；否则，渲染一个指示无权限的组件。

​        返回的函数：layoutContainer 函数返回另一个函数，以 props 作为其参数。这个返回的函数充当实际的布局组件。在这个函数内部，根据配置选项渲染布局结构：如果布局不为空（isEmpty 为 false），则渲染具有标题、侧边栏、内容区域和页脚的布局。如果布局为空，则只渲染内容区域。根据 simpleHeader 选项条件性地渲染简化的标题。根据 showSideBar 选项条件性地渲染侧边栏。如果在 pageConfig 中提供了面包屑导航，则渲染面包屑导航。渲染内容时，通过 renderContent 函数检查页面权限。如果布局为空，则直接渲染内容，不包含任何额外的布局元素。

​		导出的布局：导出了三种类型的布局：BaseLayout、SimpleLayout 和 EmptyLayout，每种都具有不同的配置：BaseLayout 包括侧边栏和标准标题。SimpleLayout 具有简化的标题（无头像）和没有侧边栏。EmptyLayout 仅渲染内容，没有任何额外的布局元素。

```tsx
import React from 'react';
import { Breadcrumb } from '@alifd/next';
import { getPageLayoutConfig } from '@/config/pageLayoutConfig';
import PageEntry from '@/components/PageEntry/index';
import Header from './components/Header';
import SideBar from './components/SideBar';
import Footer from './components/Footer';
import NoPermission from '@/components/NoPermission';
import { GlobalProvider } from './context';
import { checkCurrentPagePermission } from '@/utils/permission';
import './index.less';
import classnames from 'classnames';

const layoutContainer = (layoutConfig) => {
  const { showSideBar = false, simpleHeader = false, isEmpty = false } = layoutConfig || {};
  // 获取不同路径下的页面layout配置
  const pageConfig = getPageLayoutConfig();
  const { useLoginInfo = true, showFoot = false, showAvatar = true, isRedirect = false } = pageConfig;
  // 重定向路由，跳过layout
  if (isRedirect) return ({ children }) => children;
  // 【权限管控】校验当前页面是否有权限
  const renderContent = (children) => {
    return checkCurrentPagePermission() ? children : <NoPermission styles={isEmpty ? { height: '100vh' } : {}} />
  }

  return (props) => {
    return (
      <PageEntry>
        <GlobalProvider useLoginInfo={useLoginInfo}>
        {
          !isEmpty ? (
              <div className="layout-wrap">
                <div className="layout-header">
                  {!simpleHeader ? <Header /> : <Header showAvatar={showAvatar} useLoginInfo={useLoginInfo} />}
                </div>
                <div className="layout-body">
                  {showSideBar && <div className="layout-body-sidebar">
                    <SideBar />
                  </div>}
                  <div id='layoutContent' className={classnames(["layout-body-content-wrap", { "layout-body-content-simple-layout": simpleHeader }])}>
                    <div className="layout-body-content">
                      {
                        pageConfig?.breadcrumb?.length ? (
                          <Breadcrumb className="panama-breadcrumb">
                            {
                              (pageConfig.breadcrumb || []).map((item, index) => (
                                <Breadcrumb.Item key={index} link={item.value}>{item.label}</Breadcrumb.Item>
                              ))
                            }
                          </Breadcrumb>
                        ) : null
                      }
                      {renderContent(props.children)}
                    </div>
                  </div>
                </div>
                {showFoot ? <Footer /> : null}
              </div>
          ) : renderContent(props.children)
        }
        </GlobalProvider>
      </PageEntry>
    );
  };
}


const BaseLayout = layoutContainer({ showSideBar: true });
const SimpleLayout = layoutContainer({ simpleHeader: true });
const EmptyLayout = layoutContainer({ isEmpty: true });

export { BaseLayout, SimpleLayout, EmptyLayout };
```



## 4.3用户登录和权限模块

### 4.3.1用户登录

我们会有一个用户登录的处理，大概的逻辑：

```jsx
import React, { useState } from 'react';
import { Login, ConfigProvider } from '@../MemberUserAuth';
import { API_CONFIG, BIZ_SEGMENT } from '@/config/memberSDK';
import getSearchParams from '@/utils/getSearchParams';
import { push } from '@/utils/router';
import './index.scss';

export default (props) => {
  const { locale } = props || {};

  return (
    <section>
      <ConfigProvider
        className='sdkContainer'
        bizSegment={BIZ_SEGMENT}
        apiConfig={API_CONFIG}
      >
        <Login 
          validator={{
            email: (rule, value) => {
              return new Promise((resolve, reject) => {
                if (value.length < 6) {
                  reject(locale.emailLimit);
                } else {
                  resolve();
                }
              });
            }
          }}
          render={{
            email: {
              placeholder: locale.loginNamePlaceholder,
              requiredMessage: locale.loginNameRequired,
            },
            password: {
              placeholder: locale.passwordPlaceholder,
              requiredMessage: locale.passwordRequired,
            },
          }}
          onLoginSuccess={() => {
            push(getSearchParams('redirect') ? getSearchParams('redirect') : '/apps/dashboard', '_self', { spmc: 'login', spmd: 'loginBtn' });
          }}
        />
      </ConfigProvider>
    </section>
  );
};

```

### 4.3.2路由权限

基础的权限控制会在服务端处理，服务端返回静态资源时候，将用户所拥有的权限配置挂载在window的permissionPage上，

```html
// src/rouets.ts

// 工作台首页
import Dashboard from './pages/Dashboard';

/** * ======================================================================== *
baseLayout *
======================================================================== * */ 

const routerConfig = [
{ path: '/', component: BaseLayout, children: 
[ // 工作台首页 
  { path:'/dashboard', component: Dashboard, pageConfig: { spm: 'dashboard' } }, 
  //订单/采购管理部分 
  { path: '/order/list', component: OrderList, pageConfig: {spm: '26915986' } }, 
  { path: '/workorder/list', component: WorkorderList,pageConfig: { spm: 'workorder_list' } }, 
  { path: '/refund/list', component: RefundList, pageConfig: { spm: 'refund_list' } }, 
  { path: '/refund/detail', component: RefundDetail, pageConfig: { spm: '26186852' } }, 
  { path: '/cart/list', component: CartList, pageConfig: { spm: 'cart_list' } }, 
  { path: '/cart/confirm', component: CartConfirm, pageConfig: { spm: 'confirm_cart_list'} }, 
  // 公告 
  { path: '/announce/list', component: AnnounceList, pageConfig: {spm: 'announce_list', permissionControl: false, } }, 
  { path: '/announce/detail',component: AnnounceDetail, pageConfig: { spm: 'announce_detail', permissionControl: false, } }, 
// 选品铺货 
{ path: '/product/list', component: ProductList, pageConfig: { spm: '20960503' } }, 
{ path: '/distribute/list', component: DistributeList, pageConfig: { spm: '21025972' } }, 
{ path:'/distribute/taskList', component: DistributeTaskList, pageConfig: { spm: 'distribute_task_list' } }, 
{ path: '/selection/list', component: SelectionList, pageConfig: { spm: 'selection_list' } }, 
{ path: '/selection/create', component:SelectionCreate, pageConfig: { spm: 'selection_create' } }, 
{ path: '/selection/edit/:sid', component: SelectionCreate, pageConfig: { spm: 'selection_edit' } }, 
{ path: '/selection/copy/:sid', component: SelectionCreate, pageConfig: { spm: 'selection_copy' } }, 
{ path: '/selection/detail/:sid', component: SelectionCreate, pageConfig: { spm: 'selection_detail' } }, 
// FBI报表 
{ path: '/report/list/:reportId', component: ReportList, pageConfig: { spm: 'report_list' } }, 
//对账管理——兼容发布过程中的老路由逻辑，后期可删除此路由及对应page 
{ path:'/bill/list', component: BillList, pageConfig: { spm: '21296137' } }, 
{ path: '/refundBill/list', component: RefundBillList, pageConfig: { spm:'refund_bill_list' } }, 
// 物流详情 
{ path: '/logistics/detail', component: LogisticsDetails, pageConfig: { spm: 'logistics_detail' } }, 
// 返佣管理 
{ path: '/account/bindPub', component: AccountBindPub, pageConfig: { spm: 'bind_pub_account' } }, 
// 员工管理 
{ path: '/account/list', component: AccountList, pageConfig: { spm: 'account_list' } }, 
{ path: '/account/create', component: AccountCreate, pageConfig: { spm: 'account_create' } }, 
{ path: '/role/list', component: RoleList, pageConfig: { spm: 'role_list' } }, 
{ path: '/role/create', component: RoleCreate, pageConfig: { spm: 'role_create' } }, 
{ path: '/role/edit', component: RoleCreate, pageConfig: { spm: 'role_edit' } },
// 工作台首页统一重定向 
{ path: '/index', ...redirect('/dashboard') }, 
{ path: '/', exact: true, ...redirect('/dashboard') }
}];


/**
 * ======================================================================
 *    【PS】再次提醒
 *    --------------------------------------------------------
 *    重定向页面，需到「src/config/pageLayoutConfig/index.ts」下
 *    增加 isRedirect 参数，用来跳过layout显示
 *    --------------------------------------------------------
 * ======================================================================
 * */
function redirect(to) {
  return { component: () => redirectWithQuery(to), pageConfig: { permissionControl: false } };
}

function redirectWithQuery(to) {
  const currentUrl = new URL(window.location);
  const redirectUrl = new URL(`/apps${to}`, currentUrl.origin);
  redirectUrl.search = currentUrl.search;
  window.location.href = redirectUrl.href;
  return null;
}



// public/index.html
<script type="text/javascript">
  // 权限配置
  window.CLINIC_PERMISSION_CONFIG = window.CLINIC_PERMISSION_CONFIG || {};
  // 基础权限页面
  PANAMA_PERMISSION_CONFIG.MENU_LIST = [
    {
      "id": "1",
      "title": "采购管理",
      "icon": "https://img.alicdn.com/imgextra/i1/O1CN01uKh7qT1IYXHhCZ1gH_!!6000000000905-2-tps-32-32.png",
      "group": [
        { "id": "14", "title": "购物车", "url": "/apps/cart/list" },
        { "id": "11", "title": "订单管理", "url": "/apps/order/list" },
        { "id": "12", "title": "退货退款", "url": "/apps/refund/list" },
        { "id": "13", "title": "工单管理", "url": "/apps/workorder/list" },
        { "id": "19", "title": "物流管理", "url": "/apps/report/list/12345678" }
      ]
    },
    {
      "id": "2",
      "title": "商品铺货",
      "icon": "https://img.alicdn.com/imgextra/i1/O1CN01OTksek1KxO0QDeqEk_!!6000000001230-2-tps-32-32.png",
      "group": [
        { "id": "23", "title": "选品管理", "url": "/apps/selection/list" },
        { "id": "24", "title": "铺货任务管理", "url": "/apps/distribute/taskList" },
        { "id": "22", "title": "铺货商品管理", "url": "/apps/distribute/list" },
        { "id": "21", "title": "商品搜索", "url": "/apps/product/list" },
      ]
    },
    {
      "id": "3",
      "title": "账单管理",
      "icon": "https://img.alicdn.com/imgextra/i2/O1CN01SacVdC1elHrO2v1dB_!!6000000003911-2-tps-32-32.png",
      "group": [
        { "id": "31", "title": "支付对账", "url": "/apps/report/list/1391465" },
        { "id": "32", "title": "退款对账", "url": "/apps/report/list/1276123" }
      ]
    },
    {
      "id": "4",
      "title": "返佣管理",
      "url": "/apps/account/bindPub",
      "icon": "https://img.alicdn.com/imgextra/i3/O1CN01A6KDta1FUvJV8029e_!!6000000000491-2-tps-32-32.png",
    },
    {
      "id": "5",
      "title": "员工管理",
      "icon": "https://img.alicdn.com/imgextra/i2/O1CN01itpcXB1W7sr9C35ZO_!!6000000002742-2-tps-32-32.png",
      "group": [
        { "id": "51", "title": "账号管理", "url": "/apps/account/list" },
        { "id": "52", "title": "岗位管理", "url": "/apps/role/list" }
      ]
    }
  ];
  
  // 权限页面
  PANAMA_PERMISSION_CONFIG.PERMISSION_LIST = [
    { "id": "0", "url": "/apps/dashboard",
      "buttonList": [
        { "id": 1111, "name": "contactSupplier" },
      ]
    },
    { "id": "0", "url": "/apps/cart/list",
      "buttonList": [
        { "id": 1111, "name": "contactSupplier" }
      ]
    },
    { "id": "0", "url": "/apps/cart/confirm",
      "buttonList": [
        { "id": 1111, "name": "contactSupplier" }
      ]
    },
    { "id": "211", "url": "/apps/product/detail",
      "buttonList": [
        { "id": 1111, "name": "contactSupplier" },
        { "id": 2222, "name": "cancelDistribute" }
      ]
    },
    { "id": "22", "url": "/apps/distribute/list",
      "buttonList": [
        { "id": 1111, "name": "distribute" },
        { "id": 2222, "name": "cancelDistribute" }
      ]
    },
  ];
</script>

```

### 4.3.3按钮权限，页面权限

```
import { getVmConfig } from './getVmConfig';
import routes from '@/routes';

// 获取VM中权限配置
export function getPermissionConfig() {
  return getVmConfig('PANAMA_PERMISSION_CONFIG');
}

// 获取VM中页面目录配置
export function getMenuList() {
  return getPermissionConfig()?.MENU_LIST || [];
}
export function getMenuListMap() {
  const pathMap = {};

  function mapList(list, map) {
    list.forEach((item, index) => {
      if (item.url) {
        map[item.url] = item.id;
      }
      if (item.group?.length) {
        mapList(item.group, map);
      }
    });
    return map;
  }
  return mapList(getMenuList(), pathMap);
}

// 获取VM中按钮功能级别权限配置列表
export function getPermissionList() {
  return getPermissionConfig()?.PERMISSION_LIST || [];
}

/**
 * 获取VM中页面级别权限配置
 * @param path 可选，当前页面路径，需清除最后的"/"
 * @returns Boolean
 */
export function checkCurrentPagePermission(path?) {
  if (!path) {
    path = window.location.pathname.replace(/([^\/]+)\/$/i, '$1');;
  }
  const { inUsePermissionPathList } = getPermissionRoutesPathList();
  const permissionList = getPermissionList();

  // 异常情况:无权限控制时全部放开
  if (!permissionList.length) return true;
  // 非在役path，由route接管
  if (!inUsePermissionPathList.includes(path)) return true;
  // 仅判断在役页面，权限是否存在
  const inPermission = !!permissionList.map((item) => item.url).includes(path);
  return inPermission;
}

// 获取VM中按钮功能级别权限配置
export function getFunctionPermissionConfig(name, pathname?) {
  // 未传name时，放开权限
  if (!name) return true;
  const permissionList = getPermissionList();
  // 异常情况:无权限控制时全部放开
  if (!Array.isArray(permissionList)) return true;
  // 获取对应页面下的按钮权限列表
  const pageUrl = pathname ?? window.location.pathname;
  const functionPermissionList = permissionList.filter((item) => pageUrl === item.url);
  const functionPermissionArray = [];
  functionPermissionList.forEach((item) => functionPermissionArray.push(...(item?.buttonList ?? [])));
  // 判断按钮功能权限
  const _functionPermission = functionPermissionArray.map((item) => item.name).includes(name);
  return _functionPermission;
}

// 获取顶部导航栏全局性的功能权限，如顶部IM入口
export function getHeaderFunctionPermission(name) {
  return getFunctionPermissionConfig(name, '/apps/dashboard');
}

// 解析并分类在役页面path
function getPermissionRoutesPathList() {
  const inUsePathList = [];
  const redirectPathList = [];
  const inUsePermissionPathList = [];

  function pushAllPath(list = [], rootPath = '', permissionControl = false) {
    list.forEach((route) => {
      const curPath = [rootPath, route.path || ''].join('').replace('//', '/').replace(/([^\/]+)\/$/i, '$1');
      // 目前在路由中permissionControl显示标识为true的，才进行权限校验，
      // permissionControl标识为false的路由不生效，代表所有用户都具备该页面权限（不标识则默认为false）
      const _permissionControl = route?.pageConfig?.permissionControl !== undefined ? route?.pageConfig?.permissionControl : permissionControl;
      if (route.redirect) {
        !redirectPathList.includes(curPath) && redirectPathList.push(curPath);
      } else if (route.path && !route.children?.length) {
        // 所有在役页面
        !inUsePathList.includes(curPath) && inUsePathList.push(curPath);
        // 仅 BaseLayout 下属页面为权限校验页面
        if (_permissionControl) {
          !inUsePermissionPathList.includes(curPath) && inUsePermissionPathList.push(curPath);
        }
      }
      pushAllPath(route.children, curPath, _permissionControl);
    });
  }
  // 置入根路由apps，对应app.tsx配置
  pushAllPath(routes, '/apps');
  // 置入绝对路径的根路由
  redirectPathList.push('/');
  return { inUsePathList, redirectPathList, inUsePermissionPathList };
}

```

1. 摘要：背景意义采用开发的技术 三段论，
2. 系统的测试 - 针对系统的测试 - 性能测试
3. 国内外研究现状 ： 开发系统的国内外研究，研究系系统功能的不足，不是针对制度的尝试。

1. er图，设计的表太多了，要有阐述，功能作用，主键。

5. 详细实现：前后端接口是如何连接的，把实现的技术写出来，页面的布局实现
6. 第四章节增加4.1/4.2/4.3，系统设计，页面布局，用户登录和鉴权

## 摘要

https://eecs.pku.edu.cn/__local/A/D1/35/CA2276EEFC0FB5331ECBAE9A69E_917206E6_35AD4.pdf?e=.pdf

摘要的内容可采用三段式，即：第一段：软件针对何种应用，解决什么问题。 第二段：论文的主要工作是什么，采用的技术和方法是什么，特点是什么，成果 是什么，应用或测试情况如何等，列出几点，并加以简要说明。第三段：介绍论 文的内容组织及章节编排，首先是……接下来是……然后是……最后是总结及进一 步的工作展望。

---

​		随着社会的发展和对公共健康需求的日渐增长，中国的医疗行业吸引了广泛的社会关注，特别是医疗资源的稀缺性以及其不平等的分布状况。政府为应对这些挑战，加大了对家庭医生制度推广的力度，出台了一系列政策以促进家庭医生制度的落实，尤其是在基层医疗体系中。这样的系统不仅能够连接医生和居民，构建起一个无缝沟通的数字化平台，还能替代旧式的纸质流程，提高医疗服务的效率和便利性。尽管基于传统架构的家庭医生服务系统能满足最初的使用要求，但它们的紧耦合设计、有限的伸缩性以及维护的复杂性，成为了随后发展的瓶颈。这种架构在新需求出现时难以做出迅速响应，而一旦某个模块发生故障，可能会导致整个系统停摆，因此市场上亟需一种更为灵活、高效的解决方案。这就要求我们采取先进的技术架构来构建新一代家庭医生服务系统，确保系统能随着市场需求的演变而快速适应变化，同时降低单点故障带来的影响，保障长期运营的稳定性和可持续性。

​		本项目成功地通过Node.js框架对传统的家庭医生服务系统进行了升级，旨在解决传统架构中存在的一系列问题。我们采纳了一个高效的事件驱动架构，并实现了非阻塞的I/O处理，本系统为家庭医生赋能，提高了整个服务的性能和响应速度。在本系统中，用户不仅能够便捷地与签约医生互动，还能轻松预约体检和获取健康咨询服务。此外，系统后端允许管理员通过有力的工具来进行体检管理、医生管理和运营数据分析，提升了运营效率和决策质量。核心的系统变革在于采用了微服务架构，它取代了传统的集中式模型。在这个新架构下，各个子系统的表现层和服务层得到了完全解耦。服务被细分为独立单元，既增加了各系统间的复用性，又实现了完全的服务化。这一转变带来了极高的系统灵活性和可维护性，使各组件之间的耦合度大大降低。随着服务需求的变化，各服务模块可以方便地进行升级和扩展，而不影响整个系统的稳定性。此外，该系统具备自愈能力，即便在单个服务出现故障的情况下，也能保证系统的整体可用性。服务系统在前端采用React.js后，通过组件化开发实现了高可维护性和复用性，同时利用虚拟DOM和异步渲染优化了性能和响应速度。React.js还提供了强大的开发工具和高效的状态管理，提高了开发效率和数据一致性。结合服务端渲染则提升了SEO效果和首屏加载速度，整体上为用户和管理员提供了更流畅、更高效和更易维护的健康服务平台。综上所述，基于Node.js和React.js构建的这款家庭医生服务系统不仅在技术层面上克服了传统架构的限制，还通过现代化的架构设计，为用户和管理员提供了一套高效率、易操作、并容易维护的健康服务平台。

---

随着社会的发展和对公共健康需求的日益增长，中国医疗行业面临医疗资源稀缺和不平等分布的问题。政府通过推广家庭医生制度，出台政策加强基层医疗体系建设。这些系统通过数字化平台连接医生和居民，取代旧式纸质流程，提高医疗服务的效率和便利性。然而，传统架构的紧耦合设计、有限的伸缩性和复杂的维护性，已成为发展的瓶颈，亟需更灵活、高效的解决方案，以快速适应市场需求变化，保障系统稳定性和可持续性。

本项目利用Node.js框架对传统家庭医生服务系统进行了升级，采用高效的事件驱动架构和非阻塞I/O处理，提升了性能和响应速度。用户可以便捷地与医生互动、预约体检和获取健康咨询服务。系统后端通过微服务架构实现了各子系统的解耦，增强了复用性和服务化，带来了系统的高灵活性和可维护性。即便单个服务出现故障，系统的自愈能力也能保证整体可用性。前端采用React.js，通过组件化开发实现高可维护性和复用性，利用虚拟DOM和异步渲染优化性能和响应速度，结合服务端渲染提升了SEO效果和首屏加载速度。总体而言，基于Node.js和React.js的家庭医生服务系统在技术上克服了传统架构的限制，提供了一套高效、易操作且易维护的健康服务平台。

本文主要工作如下：

(1) 鉴于传统集中式架构的局限性，本系统转向采用分布式架构的模式。利用Node.js强大的异步事件驱动特性，我们集成了流行的Express.js框架来作为Web服务的核心，并在此基础上构建了整个系统的模块。为了优化系统并提高性能，我们引入了服务发现与管理中间件Consul或Etcd，代替传统的ZooKeeper注册中心。为了处理定时任务，我们采用了Node.js的定时器功能或Node-Schedule库，它提供了类似Quartz的定时能力，但与Node.js的事件循环机制协同得更加天然。基于Node.js技术栈所涵盖的特性和生态，本着模块化和服务化的原则，我们开发的家庭医生服务系统在实现高并发处理、快速响应客户端请求的同时，也保证了系统的高可用性和易维护性。

2.鉴于传统前端技术的局限性，本系统前端采用现代化技术栈。利用React.js的组件化开发和ReactDOM的高效DOM操作，我们构建了模块化前端。引入TypeScript提供静态类型检查，提升代码维护性。使用React Context API或Redux管理状态，确保数据一致性。通过React Router实现流畅的单页应用导航。利用虚拟DOM和异步渲染优化性能，基于React.js技术栈，我们确保系统高性能、高可用和易维护。

(2) 在上述技术的基础上，开发了一款管理端的功能齐全、性能稳定的家庭医生服务系统。

(3) 对系统功能模块和性能进行测试，其中性能测试以访问次数最多的登录页面为例。测试结果显示，本系统功能运行正常，系统响应时间短、错误率为0。

(4) 最后，对本文工作进行总结，对系统存在的不足进行了分析总结，提出改进方向。



-----



​		随着健康管理意识的提高，各类线上健康服务平台如雨后春笋般涌现，如平安好医生、春雨医生、丁香医生等。它们分别针对不同需求提供了个性化服务。然而，对于家庭医生服务而言，现有平台仍存在不少待解决的问题。主要问题体现在以下几个方面：复杂的功能布局与信息繁琐：许多现有健康平台的用户界面混乱，核心功能不突出，导致用户体验差；专业医疗资源的有限接入：用户需要在多个平台间切换以获得全面的健康咨询，效率低下。家庭医生与签约居民之间缺乏有效协作：现有系统没有很好地搭建起家庭医生和签约户之间沟通的桥梁。平台用户覆盖面广度不足：针对特定领域的健康服务应用无法满足用户更广泛的健康需求。服务模式以被动参与为主：家庭医生的功能发挥局限在对患者反馈的被动响应上，而非主动介入。

​		基于这些挑战，此系统解决了如下问题：优化用户界面与功能体验：软件采用直观简洁的设计，去除冗余功能，使用户轻易找到所需信息并获得预期服务。集成一站式专业医疗资源：平台引入多元化的合作医疗资源，为用户提供从常规咨询到专业检查的综合服务。建立高效的协作渠道：软件创新性地设立了家庭医生和签约户间的直衔通道，通过即时通讯和日常健康监控增强双方的互动。扩大用户覆盖并沉淀用户群体：平台提供的服务涵盖广泛健康需求，能够吸引并留住不同类型的用户群体。激励家庭医生的主动参与：我们的系统重视家庭医生的积极角色，配备工具和激励机制鼓励医生提供主动且连续的健康指导。

​		本文针对传统系统架构的不足，基于Node.js框架设计并实现了一款高性能、事件驱动、非阻塞的I/O模型的家庭医生服务系统。该系统不仅可以提供签约医生的服务，也可以提供预约体检和进行健康咨询等服务，也支持管理员进行体检管理、医生管理、运营数据分析等一系列管理操作，并且系统架构由分布式架构替代了传统集中式架构，基于此架构，各个子系统表现层和服务层完全分离，服务进行单独拆分，为给各个子系统提供进行可复性调用，使服务系统完全服务化，使得系统松耦合、提高灵活度和可维护性。

Node.js能够通过其生态系统中的不同工具和库来实现类似Dubbo的分布式服务系统。Node.js是一个基于Chrome V8引擎的JavaScript运行环境，适合构建高性能、事件驱动、非阻塞的I/O模型的服务端应用程序，这使得它特别适合开发分布式系统和微服务架构。

为了设计和实现一个分布式家庭医生服务系统，你可以考虑以下Node.js的工具和策略：

1. **微服务架构**：使用Node.js构建微服务，每个微服务处理系统的不同部分，例如用户管理、预约服务、病历管理等。可以使用像Express.js这样的框架简化路由和中间件管理。
2. **消息队列**：使用RabbitMQ、Kafka或其他消息代理来处理服务之间的异步通信。这可以用来实现服务的解耦和消息的缓冲。
3. **服务注册与发现**：可以使用Consul、Etcd或Eureka来构建服务注册与发现机制，这对于微服务之间的互联互通非常关键。
4. **负载均衡**：使用NGINX或HAProxy实现负载均衡，确保请求分发到不同的服务实例，从而提高系统的可用性和扩展性。
5. **容器化与编排**：将应用程序容器化可以使用Docker，而容器编排可以使用Kubernetes或Docker Swarm。这些工具支持应用在多个服务器或集群上的部署、扩展和管理。
6. **流通信和实时处理**：如果系统需要流式数据处理，可以使用WebSocket或Socket.io来实现实时的通信机制。
7. **监控与日志**：对分布式系统进行监控和日志记录是关键，可以使用Prometheus和Grafana进行监控，使用ELK Stack(Elasticsearch、Logstash、Kibana)或其他日志管理解决方案处理日志。
8. **配置管理**：可以用诸如config、dotenv等Node.js库来管理不同环境下的配置，并将敏感信息保持在安全的地方。
9. **API网关**：使用API网关管理微服务的入口，可以利用如Express Gateway或Kong这样的API网关来集中处理身份验证、授权和流量限制等问题。
10. **数据库与缓存**：选择适合的数据库系统（如MongoDB、PostgreSQL等）来存储数据，使用Redis作为缓存层来提高应用性能。

使用Node.js来实现这样的需求并不是没有挑战，但是其活跃的社区和丰富的模块库提供了很多开箱即用的解决方案，这大大降低了实现复杂分布式系统的难度。

## 系统性能测试

本项目拆分前端和后端两部分系统测试，前端测试主要包含balbalaba，后端测试，出了开发过程中的争产过的接口单元测试，还要对系统进行压测，能接接收多大量级的用户同时访问。

测试场景： 单线程情 况下 ， １万个用户同时登录查询用户信息

在 １０ 个 线程 、 １万 个用户同时查询场景下 ， 接口平均耗时７３ｍｓ ， 百分之九十的用户在２５ ０ｍｓ以下 ，最大延迟在２ｓ以 下 ， 基本符合项目预期。

// 缺一张图

| 业务场景       | 数据类型       | 达标范围      | 实际数值   | 达标 |
| -------------- | -------------- | ------------- | ---------- | ---- |
| 内存使用       | 平均内存使用量 | <= 500MB      | 450MB      | 通过 |
| CPU使用        | 平均CPU使用率  | <= 50%        | 40%        | 通过 |
| 数据库查询性能 | 平均查询时间   | <= 100ms      | 80ms       | 通过 |
| 缓存命中率     | 缓存命中率     | >= 95%        | 97%        | 通过 |
| 错误率         | 请求错误率     | <= 1%         | 0.5%       | 通过 |
| 吞吐量         | 请求处理能力   | >= 1000 req/s | 1200 req/s | 通过 |
| 吞吐量         | 并发用户数     | >= 500 users  | 550 users  | 通过 |
| 并发用户数     | 每秒处理时间   | <= 2s         | 1.8s       | 通过 |

## 国内外研究现状 

https://m.ofweek.com/medical/2023-09/ART-11159-8420-30611012.html

https://jnmu.njmu.edu.cn/sk/aumnss/article/html/20230606%C3%A5

https://www2.deloitte.com/content/dam/Deloitte/cn/Documents/life-sciences-health-care/deloitte-cn-lshc-internet-hospitals-in-china-the-new-step-into-digital-healthcare-zh-210315.pdf 

随着中国医疗卫生资源的短缺问题逐渐凸显，北京市领先在国内推广了家庭医生制度，并通过政策扶持来推进该制度的实施。这项制度赋予了注册的医生“家庭医生”的头衔，使他们能够为周边社区居民提供方便的咨询和就医服务，家庭医生还会定期走访指定地点，保障居民的医疗需求得到满足。自2010年中国正式提出家庭医生服务概念以来，虽然该制度尚处在萌芽阶段，但它的核心在于建立起医生和患者之间的信任关系。尽管在当前国内发展情况下，要实现这一目标仍有较大挑战，但随着信息技术和网络的迅猛发展，参考国际上相关成功经验，中国的沿海和发达城市开始逐步探索家庭医生服务的可行路径。特别是随着联网医疗技术的进步，我们前所未有地接近于实现“居家即可问诊”的服务模式。在成都的双流区，得益于快速的经济发展，政府能够投入更多资源改善民生和卫生状况。双流区在家庭医生制度的实施方面已经积累了基础条件，包括医护人员的引进与培训、财政的支持以及区域卫生信息化的发展规划等，这些都为实现有效的家庭医生管理系统创造了良好的前提。  

中国家庭医生制度发展面临的挑战主要包括四个方面：医疗服务中心缺乏普及：家庭医生制度要想成功实施，需要医疗服务中心覆盖广泛并向公众开放，使得家庭医生服务得以广泛接触并服务于社区居民。医疗保险体系尚未完善：当前我国医疗保险和社会保险体系未能充分涵盖所有患者，导致许多人不能享受到国家的健康治疗报销政策，这增加了家庭医生服务的经济负担。医生资源不足：随着患者数量的增加，医生特别是合格的家庭医生资源显得不足，限制了家庭医生制度的扩展和深入。公众认知度不高：尽管家庭医生制度能够在社区层面提供便捷的医疗服务，但由于宣传不足，许多人仍然不了解这一制度，不知道如何利用家庭医生提供的服务。这四个问题的存在使得家庭医生制度在推行过程中进展缓慢，解决这些问题需要政府、医疗机构和社会各界的合力协作，以及政策的支持和公众教育的加强。  

在国际范围内，家庭医生系统的发展较早，且已经非常成熟，这得益于几个关键因素：人口规模与分布：国外尤其是在发达国家，人口密度相对较低，医生对服务的人群数量有更大的覆盖能力。例如，在美国，家庭医生并不是仅为高收入人群服务的专利，相反，很多收入适中甚至较低但拥有医疗保险的人也能享有家庭医生的服务。家庭医生负责跟进病患的常规健康状况，定期进行体检。医生角色与服务范围：在美国，医生主要分为两类，即专科医生和私人(家庭)医生。私人医生可以在自己的诊所提供基本医疗服务，同时如果遇到复杂病症，也会将病人转介给专科医生。而前往专科医院就医通常需要私人医生的推荐。家庭医生在英国的全面服务：在英国，家庭医医生制度比美国更为全面，不仅提供医疗保健和健康体检服务，还涵盖慢性疾病的管理。家庭医生是病患问诊的第一扇“大门”，通常能够解决90%的病症。澳大利亚的家庭医生选择机制：澳大利亚政府允许居民自由挑选家庭医生，从而促进了合理的市场竞争，并通过检查监管制度来规范医疗服务行为。理想的家庭医生服务规模是每位医生负责大约600-800名居民。信息系统的整合：这些国家通常有着成熟的医疗信息管理系统，并且各个子系统之间实现了数据共享，确保了家庭医生和居民间的交流、就诊信息、健康指导等都能够被高效地记录和跟踪。我们能够看出，家庭医生在国外的成功关键在于合理的患者医生比率、广泛的医疗服务范围、综合的服务系统及有效的市场和监管机制。所有这些因素共同使得国外的家庭医生系统能够高效运作，为广大居民提供贴心、全面的医疗卫生服务。  

国内目前实施的家庭医生管理系统因受地理和区域的差异性影响，呈现出地域性支局限性，不同国家对家庭医生服务的需求和预期也不尽相同，导致这些系统的通用性和移植性相对较低。此外，国内从业的家庭医生在专业水平上也存在一定的不均衡，这就使得需要一套操作简便、易于理解的管理软件系统来支撑家庭医生的工作和管理。为了有效对接家庭医生的职业需求，软件系统需要优化网络资源的利用，以便软件能够在不同的运行环境下稳定工作，且不能对硬件配置提出过高要求。同时，家庭医生管理系统应具备高准确性和透明性，以便通过数据的精确记录和共享，增强家庭医生与居民之间的相互信任，从而促进家庭医生制度的健康发展和深入人心。 

## ER图

![ER图](https://s2.loli.net/2024/05/16/mYlxecJ25pNhOAP.png)









